import os


def write(project_path: str) -> None:
    get_compiler_path = os.path.join(project_path, "get_compiler")
    os.makedirs(get_compiler_path, exist_ok=True)
    with open(
        os.path.join(get_compiler_path, "__init__.py"), "w", encoding="utf-8"
    ) as f:
        f.write(
            f"""\
import os
import subprocess

Dir = os.path.dirname(__file__)


def main() -> str:
    if subprocess.run(["cmake", "--version"]).returncode:
        raise RuntimeError("Could not find cmake")

    # get the compiler id and version
    if subprocess.run(
        ["cmake", "-S", Dir, "-B", os.path.join(Dir, "build")]
    ).returncode:
        raise RuntimeError(
            "Could not find a C++ 20 compiler. Do you have a C++ 20 compiler installed?"
        )

    # Get the compiler variables generated by the cmake file
    with open(os.path.join(Dir, "build", "compiler_id.txt")) as f:
        compiler_id_str = f.read().strip()
    with open(os.path.join(Dir, "build", "compiler_version.txt")) as f:
        compiler_version = f.read().strip()

    # convert the compiler id to an int so it can be used in a version number
    compiler_id_int = 0
    for b in compiler_id_str.encode("utf-8"):
        compiler_id_int <<= 8
        compiler_id_int += b

    # combine the compiler id and compiler version into a version number
    return f"==3.0.0.{{compiler_id_int}}.{{compiler_version}}"
"""
        )

    with open(
        os.path.join(get_compiler_path, "CMakeLists.txt"), "w", encoding="utf-8"
    ) as f:
        f.write(
            f"""\
cmake_minimum_required(VERSION 3.13)

project(get_compiler LANGUAGES CXX)

# Set C++20
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

write_file("${{CMAKE_BINARY_DIR}}/compiler_id.txt" "${{CMAKE_CXX_COMPILER_ID}}")
write_file("${{CMAKE_BINARY_DIR}}/compiler_version.txt" "${{CMAKE_CXX_COMPILER_VERSION}}")
"""
        )
